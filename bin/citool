#!/usr/bin/python -u
import sys
import traceback

import libci

from libci import libciError
from libci import libciRetryError


def print_error(string):
    sys.stderr.write('Error: %s\n' % string)


def error(string):
    print_error(string)
    sys.exit(1)


def split_argv(argv_all, plugins):
    args = []
    argv_plugins = []
    argv_ci = []
    plugin = None

    for argv in argv_all:
        if argv in plugins:
            if plugin:
                argv_plugins.append({plugin: args})
            else:
                argv_ci = args
            args = []
            plugin = argv
        else:
            args.append(argv)

    # add last one
    if plugin:
        argv_plugins.append({plugin: args})
    else:
        argv_ci = args

    return (argv_ci, argv_plugins)


def main():
    # init used vars
    ci = None
    plugin = None

    try:
        # initialize ci, load the plugin list
        ci = libci.Ci()

        # split the args and parse citool args
        (ci_args, plugins_args) = split_argv(sys.argv[1:], ci.plugin_list())
        ci.parse_args(ci_args)

        ci.debug('Parsed ci args: %s' % ci_args)
        ci.debug('Parsed plugin args: %s' % plugins_args)

        # version
        if ci.get_config('version'):
            sys.stdout.write('citool %s\n' % libci.__version__.strip())
            sys.exit(0)

        # list plugins
        groups = ci.get_config('list')
        if groups is not None:
            sys.stdout.write('%s\n' % ci.plugin_list_usage(groups))
            sys.exit(0)

        # no plugins
        if not plugins_args:
            msg = 'No plugin specified, use -l to list available'
            raise libciError(msg)

        # command-line info
        if ci.get_config('info'):
            ci.print_cmdline(ci_args, plugins_args)

        # actually the execution loop is retries+1
        # there is always one execution
        retries = ci.get_config('retries')
        for i in range(retries+1):
            try:
                # destroy all plugins if they exist
                # this will call their destructor, where plugins should keep
                # their cleanup procedures
                ci.destroy_plugins()

                # print retry info
                if i:
                    sys.stderr.write('\n')
                    ci.info('retrying execution (attempt %s out of %s)' %
                            (i, retries))

                # create a separate parser for each plugin, including ci itself
                for plugin_args in plugins_args:
                    for plugin_name, args in plugin_args.iteritems():
                        plugin = ci.add_plugin_instance(plugin_name)
                        plugin.init_options_config()
                        plugin.parse_args(args)
                        plugin.check_required_options()
                        plugin.check_options()

                # execute all plugins
                for plugin in ci.plugin_instances:
                    # make sure we have a clean state in case of retries
                    plugin.execute()
                    plugin.add_shared()
            except libciRetryError as e:
                sys.stderr.write('error in %s: %s\n' % (plugin.name, e))
                continue
            break

    except (SystemExit, KeyboardInterrupt) as e:
        raise e
    except libci.libciError as e:
        if ci:
            if ci.get_config('verbose') or ci.get_config('debug'):
                traceback.print_exc()
        if plugin:
            exstr = 'error in %s: %s\n' % (plugin.name, e)
        else:
            exstr = 'error: %s\n' % e
        sys.stderr.write(exstr)
        sys.exit(-1)
    except Exception, e:
        traceback.print_exc()
        exstr = '%s' % e
        sys.stderr.write(exstr)
        sys.exit(-1)
    finally:
        if ci:
            ci.destroy_plugins()

if __name__ == '__main__':
    main()
