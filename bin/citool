#!/usr/bin/python -u
import sys
import traceback

import libci

from libci import LibciError
from libci import LibciRetryError

def print_error(string):
    sys.stderr.write('Error: %s\n' % string)


def error(string):
    print_error(string)
    sys.exit(1)


def split_argv(argv_all, modules):
    args = []
    argv_modules = []
    argv_ci = []
    module = None

    for argv in argv_all:
        if argv in modules:
            if module:
                argv_modules.append({module: args})
            else:
                argv_ci = args
            args = []
            module = argv
        else:
            args.append(argv)

    # add last one
    if module:
        argv_modules.append({module: args})
    else:
        argv_ci = args

    return (argv_ci, argv_modules)


def main():
    # init used vars
    ci = None
    module = None

    try:
        # initialize ci, load the module list
        ci = libci.Ci()

        # split the args and parse citool args
        (ci_args, modules_args) = split_argv(sys.argv[1:], ci.module_list())
        ci.parse_args(ci_args)

        ci.debug('Parsed ci args: %s' % ci_args)
        ci.debug('Parsed module args: %s' % modules_args)

        # version
        if ci.get_config('version'):
            sys.stdout.write('citool %s\n' % libci.__version__.strip())
            sys.exit(0)

        # list modules
        groups = ci.get_config('list')
        if groups is not None:
            sys.stdout.write('%s\n' % ci.module_list_usage(groups))
            sys.exit(0)

        # no modules
        if not modules_args:
            msg = 'No module specified, use -l to list available'
            raise LibciError(msg)

        # command-line info
        if ci.get_config('info'):
            ci.print_cmdline(ci_args, modules_args)

        # actually the execution loop is retries+1
        # there is always one execution
        retries = ci.get_config('retries')
        for i in range(retries+1):
            try:
                # destroy all modules if they exist
                # this will call their destructor, where modules should keep
                # their cleanup procedures
                ci.destroy_modules()

                # print retry info
                if i:
                    sys.stderr.write('\n')
                    ci.info('retrying execution (attempt %s out of %s)' %
                            (i, retries))

                # create a separate parser for each module, including ci itself
                for module_args in modules_args:
                    for module_name, args in module_args.iteritems():
                        module = ci.init_module(module_name)
                        module = ci.add_module_instance(module)
                        module.init_options_config()
                        module.parse_args(args)
                        module.sanity()
                        module.check_required_options()

                # execute all modules
                for module in ci.module_instances:
                    # make sure we have a clean state in case of retries
                    module.execute()
                    module.add_shared()
            except LibciRetryError as e:
                sys.stderr.write('error in %s: %s\n' % (module.name, e))
                continue
            break

    except (SystemExit, KeyboardInterrupt) as e:
        raise e
    except Exception as e:
        if ci:
            if ci.get_config('verbose') or ci.get_config('debug'):
                traceback.print_exc()
        if module:
            exstr = 'error in %s: %s\n' % (module.name, e)
        else:
            exstr = 'error: %s\n' % e
        sys.stderr.write(exstr)
        sys.exit(-1)
    finally:
        if ci:
            ci.destroy_modules()

if __name__ == '__main__':
    main()
